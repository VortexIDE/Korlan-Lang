# Korlan Standard Library - String Operations
# Essential string manipulation functions with @extern annotations

# Core string functions (linked to C string library)
@extern
fun strlen(str: String) -> Int {
    # Get string length
    # Links to C strlen()
}

@extern
fun strcpy(dest: String, src: String) -> String {
    # Copy string
    # Links to C strcpy()
}

@extern
fun strcat(dest: String, src: String) -> String {
    # Concatenate strings
    # Links to C strcat()
}

@extern
fun strcmp(str1: String, str2: String) -> Int {
    # Compare strings (returns <0, 0, >0)
    # Links to C strcmp()
}

@extern
fun strncmp(str1: String, str2: String, count: Int) -> Int {
    # Compare first n characters
    # Links to C strncmp()
}

@extern
fun strstr(haystack: String, needle: String) -> String {
    # Find substring
    # Links to C strstr()
}

@extern
fun strchr(str: String, c: Char) -> String {
    # Find character in string
    # Links to C strchr()
}

@extern
fun strrchr(str: String, c: Char) -> String {
    # Find last occurrence of character
    # Links to C strrchr()
}

@extern
fun memcpy(dest: Void*, src: Void*, count: Int) -> Void* {
    # Copy memory block
    # Links to C memcpy()
}

@extern
fun memmove(dest: Void*, src: Void*, count: Int) -> Void* {
    # Move memory block (handles overlap)
    # Links to C memmove()
}

@extern
fun memset(ptr: Void*, value: Int, count: Int) -> Void* {
    # Set memory block
    # Links to C memset()
}

@extern
fun memcmp(ptr1: Void*, ptr2: Void*, count: Int) -> Int {
    # Compare memory blocks
    # Links to C memcmp()
}

# High-level string operations
fun length(s: String) -> Int {
    return strlen(s)
}

fun char_at(s: String, index: Int) -> Char {
    if index < 0 or index >= length(s) {
        return '\0'  # Null character
    }
    return s[index].toChar()
}

fun substring(s: String, start: Int, length: Int) -> String {
    if start < 0 or length < 0 or start >= strlen(s) {
        return ""
    }
    
    let end = start + length
    if end > strlen(s) {
        end = strlen(s)
    }
    
    # Create new string from substring
    let result = malloc(length + 1)
    memcpy(result, s + start, length)
    result[length] = '\0'
    
    return result.toString()
}

fun starts_with(s: String, prefix: String) -> Bool {
    if strlen(prefix) > strlen(s) {
        return false
    }
    
    return strncmp(s, prefix, strlen(prefix)) == 0
}

fun ends_with(s: String, suffix: String) -> Bool {
    let s_len = strlen(s)
    let suffix_len = strlen(suffix)
    
    if suffix_len > s_len {
        return false
    }
    
    return strcmp(s + (s_len - suffix_len), suffix) == 0
}

fun contains(s: String, needle: String) -> Bool {
    return strstr(s, needle) != null
}

fun index_of(s: String, needle: String) -> Int {
    let result = strstr(s, needle)
    if result == null {
        return -1
    }
    return result - s  # Pointer arithmetic to get index
}

fun last_index_of(s: String, needle: String) -> Int {
    let result = strrchr(s, needle[0])
    if result == null {
        return -1
    }
    return result - s
}

fun split(s: String, delimiter: String) -> Array<String> {
    let result = []
    let current = s
    let delim_len = strlen(delimiter)
    
    while strlen(current) > 0 {
        let pos = strstr(current, delimiter)
        if pos == null {
            result.append(current)
            break
        }
        
        let part_len = pos - current
        let part = substring(current, 0, part_len)
        result.append(part)
        
        current = pos + delim_len
    }
    
    return result
}

fun join(strings: Array<String>, delimiter: String) -> String {
    if strings.length == 0 {
        return ""
    }
    
    # Calculate total length
    let total_len = 0
    for i in 0..<strings.length {
        total_len = total_len + strlen(strings[i])
    }
    total_len = total_len + (strings.length - 1) * strlen(delimiter)
    
    let result = malloc(total_len + 1)
    let pos = result
    
    # Copy first string
    strcpy(pos, strings[0])
    pos = pos + strlen(strings[0])
    
    # Copy remaining strings with delimiter
    for i in 1..<strings.length {
        strcpy(pos, delimiter)
        pos = pos + strlen(delimiter)
        strcpy(pos, strings[i])
        pos = pos + strlen(strings[i])
    }
    
    return result.toString()
}

fun trim(s: String) -> String {
    let start = 0
    let end = strlen(s) - 1
    
    # Find first non-whitespace character
    while start <= end and is_whitespace(char_at(s, start)) {
        start = start + 1
    }
    
    # Find last non-whitespace character
    while end >= start and is_whitespace(char_at(s, end)) {
        end = end - 1
    }
    
    if start > end {
        return ""
    }
    
    return substring(s, start, end - start + 1)
}

fun to_upper(s: String) -> String {
    let result = malloc(strlen(s) + 1)
    let i = 0
    
    while i < strlen(s) {
        let c = char_at(s, i)
        if c >= 'a' and c <= 'z' {
            result[i] = c - ('a' - 'A')
        } else {
            result[i] = c
        }
        i = i + 1
    }
    
    result[i] = '\0'
    return result.toString()
}

fun to_lower(s: String) -> String {
    let result = malloc(strlen(s) + 1)
    let i = 0
    
    while i < strlen(s) {
        let c = char_at(s, i)
        if c >= 'A' and c <= 'Z' {
            result[i] = c + ('a' - 'A')
        } else {
            result[i] = c
        }
        i = i + 1
    }
    
    result[i] = '\0'
    return result.toString()
}

fun replace(s: String, old: String, new: String) -> String {
    let first = strstr(s, old)
    if first == null {
        return s
    }
    
    let before_len = first - s
    let before = substring(s, 0, before_len)
    let after = first + strlen(old)
    
    return before + new + replace(after, old, new)
}

fun repeat(s: String, count: Int) -> String {
    if count <= 0 {
        return ""
    }
    
    let result_len = strlen(s) * count
    let result = malloc(result_len + 1)
    let pos = result
    
    for i in 0..<count {
        strcpy(pos, s)
        pos = pos + strlen(s)
    }
    
    return result.toString()
}

# Character utilities
fun is_whitespace(c: Char) -> Bool {
    c == ' ' or c == '\t' or c == '\n' or c == '\r'
}

fun is_digit(c: Char) -> Bool {
    c >= '0' and c <= '9'
}

fun is_letter(c: Char) -> Bool {
    (c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z') or c == '_'
}

fun is_alphanumeric(c: Char) -> Bool {
    is_letter(c) or is_digit(c)
}

# Type conversions
fun to_int(s: String) -> Int {
    return atoi(s)
}

fun to_float(s: String) -> Float {
    return atof(s)
}

fun from_int(n: Int) -> String {
    # Allocate enough space for max int (including sign and null)
    let buffer = malloc(12)
    sprintf(buffer, "%d", n)
    return buffer.toString()
}

fun from_float(f: Float) -> String {
    # Allocate enough space for float representation
    let buffer = malloc(32)
    sprintf(buffer, "%f", f)
    return buffer.toString()
}

# External C functions needed
@extern
fun atoi(str: String) -> Int {
    # Convert string to integer
    # Links to C atoi()
}

@extern
fun atof(str: String) -> Float {
    # Convert string to float
    # Links to C atof()
}

@extern
fun sprintf(buffer: String, format: String, ...) -> Int {
    # Formatted string output
    # Links to C sprintf()
}

# Type aliases
type Char = Int
type Array<T> = Void*
